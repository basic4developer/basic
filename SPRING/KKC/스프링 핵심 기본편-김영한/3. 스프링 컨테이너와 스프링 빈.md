2021/09/24 25일 필수 내용 위주로 순서 정렬, 의존관계 내용 추가 필요, 이슈 추가

## 생각해보기
1. 기존 AppConfig와 ApplicationContext(스프링 컨테이너) 차이는 무엇인가?
2. 어떤 경우에 스프링 컨테이너의 스프링 빈을 확인해볼까?
스프링 빈의 definition은 어떤 정보들이 있을까? 빈 정보는 어떻게 사용할 수 있을까?
3. ApplictaionContext 부가기능 4가지 알아보기
4. 클래스의 바이트코드란? CGLIB란?
5. 스프링이나 스프링 부트에서 applicationContext를 생성하지 않고, 구성정보 파라미터도 없는데 이 역할은 무엇이 하는가?

## 스프링 컨테이너와 스프링 빈
### 스프링 컨테이너(ApplicationContext)
- 스프링 컨테이너
- 인터페이스
- `new AnnotationConfigApplicationContext(AppConfig.class)` ApplicationContext 인터페이스의 구현체
- `AppConfig.class`: 스프링 컨테이너를 생성할 때 구성 정보
- 설정 정보를 참고하여 의존관계 주입(DI)
- 스프링 빈 생성, 의존 관계 주입 : 단계가 나누어져 있지만 자바 코드로 스프링 빈을 등록하면 생성자 호출 시 빈 등록, 의존 관계 주입 한번에 처리

### 스프링 빈
- 빈 이름은 항상 다른 이름 부여: 같은 이름을 부여하면 다른 빈이 무시되거나 기존 빈을 덮어버리거나 설정에 따라 오류 발생
- `@Bean(name="memberService2")` 빈이름 직접 부여 가능

### 컨테이너 등록된 빈 조회
```java
class ApplicationContextInfoTest {

    AnnotationConfigApplicationContext ac = new
    AnnotationConfigApplicationContext(AppConfig.class);

    @Test
    @DisplayName("모든 빈 출력하기")
    void findAllBean() {
        String[] beanDefinitionNames = ac.getBeanDefinitionNames();
        for (String beanDefinitionName : beanDefinitionNames) {
            Object bean = ac.getBean(beanDefinitionName);
            System.out.println("name=" + beanDefinitionName + " object=" + bean);
        }
    }

@Test
@DisplayName("애플리케이션 빈 출력하기")
    void findApplicationBean() {
        String[] beanDefinitionNames = ac.getBeanDefinitionNames();
        for (String beanDefinitionName : beanDefinitionNames) {
            BeanDefinition beanDefinition =
            ac.getBeanDefinition(beanDefinitionName);

            //Role ROLE_APPLICATION: 직접 등록한 애플리케이션 빈
            //Role ROLE_INFRASTRUCTURE: 스프링이 내부에서 사용하는 빈
            if (beanDefinition.getRole() == BeanDefinition.ROLE_APPLICATION) {
                Object bean = ac.getBean(beanDefinitionName);
                System.out.println("name=" + beanDefinitionName + " object=" + bean);
            }
        }
    }

}
```
- `ac.getBeanDefinitionNames()` : 스프링에 등록된 모든 빈 이름을 조회

- `ac.getBean("beanName")` : 빈 이름으로 빈 객체(인스턴스)를 조회
- `ac.getBean(빈이름, 타입)` ex) , `ac.getBean(타입)`도 가능
```java
@Test
@DisplayName("빈 이름으로 조회")
    void findBeanByName() {
    MemberService memberService = ac.getBean("memberService",
    MemberService.class);
    assertThat(memberService).isInstanceOf(MemberServiceImpl.class);
}

@Test
@DisplayName("이름 없이 타입만으로 조회")
    void findBeanByType() {
    MemberService memberService = ac.getBean(MemberService.class);
    assertThat(memberService).isInstanceOf(MemberServiceImpl.class);
}

//구체 타입으로 조회하면 변경시 유연성이 떨어진다. 구현체 의존
@Test
@DisplayName("구체 타입으로 조회")
void findBeanByName2() {
    MemberServiceImpl memberService = ac.getBean("memberService",
    MemberServiceImpl.class);
    assertThat(memberService).isInstanceOf(MemberServiceImpl.class);
}

@Test
@DisplayName("빈 이름으로 조회X")
void findBeanByNameX() {
    //ac.getBean("xxxxx", MemberService.class);
    Assertions.assertThrows(NoSuchBeanDefinitionException.class, () ->
    ac.getBean("xxxxx", MemberService.class));
}
```
- 스프링이 내부에서 사용하는 빈은 `getRole()` 로 구분할 수 있다.
    - `ROLE_APPLICATION` : 일반적으로 사용자가 정의한 빈
    - `ROLE_INFRASTRUCTURE` : 스프링이 내부에서 사용하는 빈
#### 빈 조회 - 동일한 타입이 둘 이상
- 오류 발생, 빈 이름 지정 필요
- `ac.getBeansOfType()` :  해당 타입의 모든 빈 조회 가능
```java
@Test
@DisplayName("특정 타입을 모두 조회하기")
void findAllBeanByType() {
    Map<String, MemberRepository> beansOfType =
    ac.getBeansOfType(MemberRepository.class);
    for (String key : beansOfType.keySet()) {
        System.out.println("key = " + key + " value = " + beansOfType.get(key));
    }
    System.out.println("beansOfType = " + beansOfType);
    assertThat(beansOfType.size()).isEqualTo(2);
}
```
#### 상속 관계
- 부모 타입으로 조회 -> 자식 타입도 함께 조회
- object 타입 조회 -> 모든 스프링 빈 조회
- 부모 부모 타입으로 조회시, 자식이 둘 이상 있으면, 중복 오류가 발생    
 => 빈 이름 지정, 특정 하위 타입 조회(비추천)
- 부모 타입으로 모두 조회 (위 특정 타입 모두 조회하기 참고 or 모두 조회)
```java
@Test
@DisplayName("부모 타입으로 모두 조회하기 - Object")
void findAllBeanByObjectType() {
    Map<String, Object> beansOfType = ac.getBeansOfType(Object.class);
    for (String key : beansOfType.keySet()) {
        System.out.println("key = " + key + " value=" +
        beansOfType.get(key));
    }
}
```

### BeanFactory와 ApplicationContext
- p61 이미지 참고
- `ApplicationContext`는 `BeanFactory`(빈 관리, 조회-getBean())의 기능을 상속받는다.
- ApplicationContext는 빈 관리기능 + 편리한 부가 기능을 제공한다.
- BeanFactory를 직접 사용할 일은 거의 없다. 부가기능이 포함된 ApplicationContext를 사용한다.
- BeanFactory나 ApplicationContext를 `스프링 컨테이너`라 한다.
- 애플리케이션을 개발할 때는 빈은 관리하고 조회하는 기능은 물론이고, 수 많은 부가기능이 필요 - `ApplicationContext`
    - 메시지소스를 활용한 국제화 기능
        - 예를 들어서 한국에서 들어오면 한국어로, 영어권에서 들어오면 영어로 출력
    - 환경변수
        - 로컬, 개발, 운영등을 구분해서 처리
    - 애플리케이션 이벤트
        - 이벤트를 발행하고 구독하는 모델을 편리하게 지원
    - 편리한 리소스 조회
        - 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회

### 다양한 설정 형식 지원 - 자바 코드, XML
- 스프링 컨테이너는 다양한 형식의 설정(구성) 정보를 받아드릴 수 있게 유연하게 설계
- XML 설정 파일: 많은 레거시 프로젝트의 설정, **컴파일 없이 빈 설정 정보 변경 가능**, `GenericXmlApplictionContext`
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
xsi:schemaLocation="http://www.springframework.org/schema/beans http://
www.springframework.org/schema/beans/spring-beans.xsd">

    <bean id="memberService" class="hello.core.member.MemberServiceImpl">
        <constructor-arg name="memberRepository" ref="memberRepository" />
    </bean>

    <bean id="memberRepository"
    class="hello.core.member.MemoryMemberRepository" />

    <bean id="orderService" class="hello.core.order.OrderServiceImpl">
        <constructor-arg name="memberRepository" ref="memberRepository" />
        <constructor-arg name="discountPolicy" ref="discountPolicy" />
    </bean>

    <bean id="discountPolicy" class="hello.core.discount.RateDiscountPolicy" />

</beans>
```

#### BeanDefinition
- 빈 설정 메타정보
- 스프링 컨테이너는 이 메타 정보를 기반으로 스프링 빈 생성
- java, XML 상관 없이 BeanDefinition만 알면 됨, Reader을 통해 정보를 읽어 `BeanDefinition` 생성
p 65 이미지
- `BeanDefinition 정보`
    - BeanClassName: 생성할 빈의 클래스 명(자바 설정 처럼 팩토리 역할의 빈을 사용하면 없음)
    - factoryBeanName: 팩토리 역할의 빈을 사용할 경우 이름, 예) appConfig
    - factoryMethodName: 빈을 생성할 팩토리 메서드 지정, 예) memberService
    - Scope: 싱글톤(기본값)
    - lazyInit: 스프링 컨테이너를 생성할 때 빈을 생성하는 것이 아니라, 실제 빈을 사용할 때 까지 최대한
    생성을 지연처리 하는지 여부
    - InitMethodName: 빈을 생성하고, 의존관계를 적용한 뒤에 호출되는 초기화 메서드 명
    - DestroyMethodName: 빈의 생명주기가 끝나서 제거하기 직전에 호출되는 메서드 명
    - Constructor arguments, Properties: 의존관계 주입에서 사용한다. (자바 설정 처럼 팩토리 역할
    의 빈을 사용하면 없음)
- BeanDefinition을 직접 생성해서 스프링 컨테이너에 등록할 수 도 있다. 하지만 실무에서 BeanDefinition을 직접 정의하거나 사용할 일은 거의 없다.

## 싱클톤 컨테이너
- 웹어플리케이션 여러 고객이 동시에 요청
- `순수한 DI 컨테이너인 AppConfig`는 **요청할 때마다 객체를 새로 생성** => 메모리 낭비
- 싱글톤 패턴 => 따로 정리 참고 링크 달기(여러 구현 방법, 장단점)
- 싱글톤 패턴 문제점
    - 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
    - 의존관계상 클라이언트가 구체 클래스에 의존한다. DIP를 위반한다.
    - 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.
    - 테스트하기 어렵다.
    - 내부 속성을 변경하거나 초기화 하기 어렵다.
    - private 생성자로 자식 클래스를 만들기 어렵다.
    - 결론적으로 유연성이 떨어진다.
    - 안티패턴으로 불리기도 한다.
- 스프링 싱글톤 문제 해결, 싱글톤 컨테이너 역할: 싱글톤 객체를 생성하고 관리하는 기능- 싱글톤 레지스트리
    - 싱글톤 패턴을 위한 지저분한 코드 X
    - DIP, OCP, 테스트, private 생성자 신경쓰지 않고 싱글톤 사용
- `주의점`: 상태(stateful) 유지 설계 X 
- 무상태(stateless) 설계 - 스프링 빈
    - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
    - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다!
    - 가급적 읽기만 가능해야 한다.
    - 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.

### @Configuration
- 스프링 컨테이너는 싱글톤 레지스트리
- 클래스의 바이트코드를 조작하는 라이브러리를 사용
- 스프링 빈의 클래스 정보
```java
AppConfig bean = ac.getBean(AppConfig.class);
System.out.println("bean = " + bean.getClass());

// 결과 bean = class hello.core.AppConfig$$EnhancerBySpringCGLIB$$bd479d70
```
-p82 사진 
- 임의의 클래스가 싱글톤 보장
- @Configuration 없이 @Bean만 사용시 싱글톤 X

## 컴포넌트 스캔
- 스프링 빈 등록: 자바코드 @Bean, XML <bean> 설정 정보에 직접 등록(수동)할 스프링 빈 작성 => 등록 및 설정 정보 복잡, 누락, 반복 문제
- `@ComponentScan`: 자동으로 스프링 빈 등록, 위와 같이 수동설정을 안하려면 이 어노테이션으로 의존관계 주입도 해결 필요 `@Autowired`: 의존관계 자동 주입
- `@ComponentScan`: @Configuration(해당 어노테이션에 @Component 포함) 설정 정보도 자동 등록 => `excludeFilters` ComponetScan에서 제외 설정 가능
- `@ComponentScan` 컴포넌트 스캔의 대상, 모두 @Component 포함
    - @Component : 컴포넌트 스캔에서 사용
    - @Controlller : 스프링 MVC 컨트롤러에서 사용, 스프링 MVC 컨트롤러로 인식
    - @Service : 스프링 비즈니스 로직에서 사용, 특별한 부가기능 x, 비즈니스 계층 인식에 도움
    - @Repository : 스프링 데이터 접근 계층에서 사용, 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 스프링 예외로 변환해준다.
    - @Configuration : 스프링 설정 정보에서 사용, 스프링 설정 정보로 인식하고, 스프링 빈이 싱글톤을 유지하도록 추가 처
리를 한다.
- `@ComponentScan`: 컴포넌트 스캔이 되는 **모든 클래스를 스프링 빈으로 등록**
    - 빈 이름 기본전략: 클래스 이름의 제일 앞 소문자
    - 빈 이름 직접 지정: @Component("memberService2")
- `basePackages` : 탐색할 패키지의 시작 위치를 지정한다. 이 패키지를 포함해서 하위 패키지를 모두 탐색한
다.
    - `basePackages` = {"hello.core", "hello.service"} 이렇게 여러 시작 위치를 지정할 수도
있다.
    - `basePackageClasses` : 지정한 클래스의 패키지를 탐색 시작 위치로 지정한다. 만약 지정하지 않으면 **@ComponentScan 이 붙은 설정 정보 클래스의 패키지가 시작 위치**가 된다.
- 권장하는 방법
    - 개인적으로 즐겨 사용하는 방법은 패키지 위치를 지정하지 않고, 설정 정보 클래스의 위치를 프로젝트 최상단에 두고, @ComponentScan 애노테이션을 붙이고, basePackages 지정 생략. 최근 스프링 부트도 이 방법을 기본으로 제공한다.
- 스프링 부트를 사용하면 스프링 부트의 대표 시작 정보인 `@SpringBootApplication` 를 이 프로젝
트 시작 루트 위치에 두는 것이 관례이다. (이 설정안에 바로 @ComponentScan 이 들어있다!)
```java
@ComponentScan(
    basePackages = {"hello.core", "hello.service"},
    includeFilters = @Filter(type = FilterType.ANNOTATION, classes =
    MyIncludeComponent.class),
    excludeFilters = @Filter(type = FilterType.ANNOTATION, classes =
    MyExcludeComponent.class)
)
/*
@Component 면 충분하기 때문에, includeFilters 를 사용할 일은 거의 없다. excludeFilters
는 여러가지 이유로 간혹 사용할 때가 있지만 많지는 않다.
> 특히 최근 스프링 부트는 컴포넌트 스캔을 기본으로 제공하는데, 개인적으로는 옵션을 변경하면서 사용하기
보다는 스프링의 기본 설정에 최대한 맞추어 사용하는 것을 권장하고, 선호하는 편이다.
*/
```
- FilterType 5가지 옵션
    - ANNOTATION: 기본값, 애노테이션을 인식해서 동작한다.
        - ex) org.example.SomeAnnotation
    - ASSIGNABLE_TYPE: 지정한 타입과 자식 타입을 인식해서 동작한다.
        - ex) org.example.SomeClass
    - ASPECTJ: AspectJ 패턴 사용
        - ex) org.example..*Service+
    - REGEX: 정규 표현식
        - ex) org\.example\.Default.*
    - CUSTOM: TypeFilter 이라는 인터페이스를 구현해서 처리
        - ex) org.example.MyTypeFilter

### 중복 등록과 충동
- 자동 빈 등록 vs 자동 빈 등록
    - 컴포넌트 스캔에 의해 자동으로 스프링 빈이 등록되는데, 그 이름이 같은 경우 스프링은 오류를 발생시킨다.
    - ConflictingBeanDefinitionException 예외 발생
- 수동 빈 등록 vs 자동 빈 등록    
    - 수동 빈 등록이 우선권을 가진다. (수동 빈이 자동 빈을 오버라이딩 해버린다.)
    - 항상 잡기 어려운 버그는 애매한 버그다.
그래서 최근 스프링 부트에서는 수동 빈 등록과 자동 빈 등록이 충돌나면 오류가 발생하도록 기본
- 수동 빈 등록, 자동 빈 등록 오류시 스프링 부트 에러
> Consider renaming one of the beans or enabling overriding by setting
- spring.main.allow-bean-definition-overriding=true
#### tip) 단순 명확한 것이 최고, 컴파일 에러


## 의존관계 자동 주입 p97


## 더 알아보기
- getClass(), instanceOf(), equals, == 정확한 차이


## 생각해보기의 현재 대답
1. - 객체 조회 방식이 다름 ac.getBean(), appConfig.memberService(),
스프링 컨테이너는 이름, 타입으로 빈 조회 가능   
    - appConfig는 해당 객체 호출 시, 매번 새로운 객체 생성, 스프링 컨테이너는 싱글톤 
2. 어플리케이션 에러나 문제가 있을 때, 스프링 빈에 등록된 것을 확인하고, definition의 구체적인 정보를 확인하며 제대로 빈생성이 되었는지 체크해볼 수 있지 않을까?
5.  @SpringBootApplication 어노테이션 안에 componentscan도 있고, applicationContext 역할의 어노테이션이 포함되어 있을 것 같다.
componentScan = 자동 빈등록, 구성정보의 @Bean 수동 빈 등록p96